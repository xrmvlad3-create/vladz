<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <title>IzaManagement – Previzualizare cod (Next.js)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.bunny.net">
  <link href="https://fonts.bunny.net/css?family=instrument-sans:400,500,600" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <style>
    :root{--bg:#0b0b0c;--panel:#101113;--muted:#9aa0a6;--primary:#f97316;--border:#24262a;--text:#e7eaee;--link:#60a5fa}
    *{box-sizing:border-box}
    html,body{margin:0;height:100%}
    body{display:flex;flex-direction:column;background:var(--bg);color:var(--text);font-family:'Instrument Sans',ui-sans-serif,system-ui,sans-serif}
    header{display:flex;align-items:center;gap:12px;padding:16px 20px;border-bottom:1px solid var(--border)}
    header .brand{font-weight:600}
    header a{color:var(--link);text-decoration:none}
    .wrap{flex:1;display:flex;min-height:0}
    nav{width:360px;border-right:1px solid var(--border);padding:16px;background:var(--panel);overflow:auto}
    nav h3{margin:0 0 8px;font-size:14px;color:var(--muted)}
    .file{display:flex;gap:8px;align-items:center;padding:8px 10px;border-radius:6px;cursor:pointer;color:var(--text)}
    .file:hover{background:#15171a}
    .file.active{background:#171a1f;border:1px solid #1f2937}
    .file small{color:var(--muted)}
    main{flex:1;display:flex;flex-direction:column;min-width:0}
    .topbar{display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border);padding:10px 16px;background:var(--panel)}
    .topbar .title{font-size:14px;color:var(--muted)}
    .code{flex:1;min-height:0;overflow:auto;padding:0}
    pre{margin:0;padding:16px}
    .hint{padding:8px 16px;color:var(--muted);border-bottom:1px solid var(--border)}
    .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#13243a;color:#7dc1ff;border:1px solid #1f3b5e;font-size:12px}
    .links{display:flex;gap:12px;align-items:center}
    .links a{color:var(--link)}
    footer{padding:12px 16px;color:var(--muted);border-top:1px solid var(--border);font-size:12px}
    @media (max-width: 960px){nav{width:260px}}
  </style>
</head>
<body>
  <header>
    <div class="brand">IzaManagement – Previzualizare cod</div>
    <div class="links">
      <a href="./index.html">Previzualizare UI statică</a>
    </div>
  </header>
  <div class="wrap">
    <nav id="sidebar">
      <h3>Fișiere cheie (Next.js monorepo)</h3>
      <div class="file" data-file="apps/web/next.config.mjs">apps/web/next.config.mjs</div>
      <div class="file" data-file="apps/web/package.json">apps/web/package.json</div>
      <div class="file" data-file="apps/web/prisma/schema.prisma">apps/web/prisma/schema.prisma</div>
      <div class="file" data-file="apps/web/prisma/seed.ts">apps/web/prisma/seed.ts</div>
      <div class="file" data-file="apps/web/src/lib/prisma.ts">apps/web/src/lib/prisma.ts</div>
      <div class="file" data-file="apps/web/src/lib/auth.ts">apps/web/src/lib/auth.ts</div>
      <div class="file" data-file="apps/web/src/lib/redis.ts">apps/web/src/lib/redis.ts</div>
      <div class="file" data-file="apps/web/src/lib/groq.ts">apps/web/src/lib/groq.ts</div>
      <div class="file" data-file="apps/web/src/lib/rate-limit.ts">apps/web/src/lib/rate-limit.ts</div>
      <div class="file" data-file="apps/web/src/app/page.tsx">apps/web/src/app/page.tsx</div>
      <div class="file" data-file="apps/web/src/app/ai/page.tsx">apps/web/src/app/ai/page.tsx</div>
      <div class="file" data-file="apps/web/src/app/admin/page.tsx">apps/web/src/app/admin/page.tsx</div>
      <div class="file" data-file="apps/web/src/app/admin/catalog/page.tsx">apps/web/src/app/admin/catalog/page.tsx</div>
      <div class="file" data-file="apps/web/src/app/api/health/route.ts">apps/web/src/app/api/health/route.ts</div>
      <div class="file" data-file="apps/web/src/app/api/seed/route.ts">apps/web/src/app/api/seed/route.ts</div>
      <div class="file" data-file="apps/web/src/app/api/cron/every-15m/route.ts">apps/web/src/app/api/cron/every-15m/route.ts</div>
      <div class="file" data-file="apps/web/src/app/api/ai-assistant/message/route.ts">apps/web/src/app/api/ai-assistant/message/route.ts</div>
      <div class="file" data-file="apps/web/src/app/api/ai-assistant/differential-diagnosis/route.ts">apps/web/src/app/api/ai-assistant/differential-diagnosis/route.ts</div>
      <div class="file" data-file="apps/web/src/app/api/ai-assistant/analyze-images/route.ts">apps/web/src/app/api/ai-assistant/analyze-images/route.ts</div>
      <div class="file" data-file=".github/workflows/cron.yml">.github/workflows/cron.yml</div>
    </nav>
    <main>
      <div class="topbar">
        <div class="title" id="filename">apps/web/next.config.mjs</div>
        <div><span class="badge" id="lang">js</span></div>
      </div>
      <div class="hint">Selectează un fișier din stânga pentru a vedea codul. Evidențierea sintaxei este activă.</div>
      <div class="code">
        <pre><code id="code" class="language-javascript"></code></pre>
      </div>
    </main>
  </div>
  <footer>Acest proiect foloseste Next.js (App Router) + Prisma + NextAuth + Postgres și se rulează nativ pe Vercel.</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    const files = {
      "apps/web/next.config.mjs": { lang: "javascript", content: `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    serverActions: true
  },
  output: 'standalone'
};

export default nextConfig;` },
      "apps/web/package.json": { lang: "json", content: `{
  "name": "izamanagement-web",
  "private": true,
  "version": "0.1.0",
  "scripts": {
    "dev": "next dev",
    "build": "node scripts/build.mjs",
    "vercel-build": "node scripts/build.mjs",
    "start": "next start -p 3000",
    "lint": "next lint",
    "prisma:studio": "prisma studio",
    "seed": "prisma db seed"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@prisma/client": "^5.17.0",
    "@upstash/redis": "^1.28.3",
    "bcryptjs": "^2.4.3",
    "next": "14.2.5",
    "next-auth": "^4.24.7",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^20.12.12",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "eslint": "^8.57.0",
    "eslint-config-next": "14.2.5",
    "prisma": "^5.17.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}` },
      "apps/web/prisma/schema.prisma": { lang: "prisma", content: `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [ { name = "pgcrypto" } ]
}

/// Users (NextAuth + app model)
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      String   @default("user")
  password  String?  // bcrypt hash for Credentials provider
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accounts  Account[]
  sessions  Session[]
}

/// Specialty taxonomy
model Specialty {
  id        String      @id @default(uuid())
  slug      String      @unique
  name      String
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  conditions Condition[]
  procedures Procedure[]
  courses    Course[]
}

/// Medical conditions
model Condition {
  id           String     @id @default(uuid())
  slug         String     @unique
  name         String
  isCommon     Boolean    @default(false)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  specialty   Specialty  @relation(fields: [specialtyId], references: [id])
  specialtyId String
}

/// Procedures
model Procedure {
  id           String     @id @default(uuid())
  slug         String     @unique
  name         String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  specialty   Specialty  @relation(fields: [specialtyId], references: [id])
  specialtyId String
}

/// Courses metadata (links to official providers)
model Course {
  id           String     @id @default(uuid())
  title        String
  provider     String
  url          String
  language     String?    @default("ro")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  specialty   Specialty  @relation(fields: [specialtyId], references: [id])
  specialtyId String
}

/// NextAuth tables (for OAuth or future providers)
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}` },
      "apps/web/prisma/seed.ts": { lang: "typescript", content: `import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  const derm = await prisma.specialty.upsert({
    where: { slug: "dermatologie" },
    update: {},
    create: { slug: "dermatologie", name: "Dermatologie" }
  });

  const conditions = [
    { slug: "acnee-vulgara", name: "Acnee vulgară", isCommon: true },
    { slug: "psoriazis", name: "Psoriazis", isCommon: true },
    { slug: "dermatita-atopica", name: "Dermatită atopică", isCommon: true },
    { slug: "dermatita-seboreica", name: "Dermatită seboreică", isCommon: true }
  ];

  for (const c of conditions) {
    await prisma.condition.upsert({
      where: { slug: c.slug },
      update: { name: c.name, isCommon: c.isCommon, specialtyId: derm.id },
      create: { ...c, specialtyId: derm.id }
    });
  }

  const hash = await bcrypt.hash(process.env.ADMIN_PASSWORD || "admin1234", 10);
  await prisma.user.upsert({
    where: { email: "admin@izamanagement.ro" },
    update: { role: "admin", name: "Administrator", password: hash },
    create: { email: "admin@izamanagement.ro", role: "admin", name: "Administrator", password: hash }
  });
}

main().finally(async () => { await prisma.$disconnect(); });` },
      "apps/web/src/lib/prisma.ts": { lang: "typescript", content: `import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"]
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;` },
      "apps/web/src/lib/auth.ts": { lang: "typescript", content: `import { PrismaAdapter } from "@next-auth/prisma-adapter";
import Credentials from "next-auth/providers/credentials";
import { prisma } from "@lib/prisma";
import type { NextAuthOptions } from "next-auth";
import bcrypt from "bcryptjs";

export const authOptions: NextAuthOptions = {
  session: { strategy: "jwt" },
  adapter: PrismaAdapter(prisma) as any,
  providers: [
    Credentials({
      name: "Credentials",
      credentials: { email: { label: "Email", type: "email" }, password: { label: "Password", type: "password" } },
      async authorize(creds) {
        if (!creds?.email || !creds?.password) return null;
        const user = await prisma.user.findUnique({ where: { email: creds.email } });
        if (!user?.password) return null;
        const ok = await bcrypt.compare(creds.password, user.password);
        return ok ? { id: user.id, email: user.email, name: user.name, role: user.role } as any : null;
      }
    })
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) token.role = (user as any).role || "user";
      return token;
    },
    async session({ session, token }) {
      (session.user as any).role = token.role || "user";
      return session;
    }
  },
  secret: process.env.NEXTAUTH_SECRET
};` },
      "apps/web/src/lib/redis.ts": { lang: "typescript", content: `import { Redis } from "@upstash/redis";

const url = process.env.UPSTASH_REDIS_REST_URL || "";
const token = process.env.UPSTASH_REDIS_REST_TOKEN || "";

export const redis = (url && token)
  ? new Redis({ url, token })
  : {
      async get() { return null; },
      async set() { return null as any; },
      async ttl() { return -1 as any; }
    } as unknown as Redis;` },
      "apps/web/src/lib/groq.ts": { lang: "typescript", content: `export type AIMessage = {
  role: "system" | "user" | "assistant";
  content: string;
};

const endpoint = "https://api.groq.com/openai/v1/chat/completions";

export async function chat({
  messages,
  model = process.env.GROQ_MODEL || "llama-3.1-70b-versatile",
  temperature = 0.2,
  max_tokens = 1024
}: {
  messages: AIMessage[];
  model?: string;
  temperature?: number;
  max_tokens?: number;
}) {
  const apiKey = process.env.GROQ_API_KEY;
  if (!apiKey) {
    throw new Error("GROQ_API_KEY not set");
  }

  const res = await fetch(endpoint, {
    method: "POST",
    headers: {
      "Authorization": \`Bearer \${apiKey}\`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model,
      temperature,
      max_tokens,
      messages
    })
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(\`Groq API error (\${res.status}): \${text}\`);
  }

  const json = await res.json();
  const content = json?.choices?.[0]?.message?.content ?? "";
  return { content, raw: json };
}` },
      "apps/web/src/lib/rate-limit.ts": { lang: "typescript", content: `import { redis } from "@lib/redis";

/**
 * Simple IP-based sliding window limiter using Upstash Redis.
 * Falls back to always-allow if Redis is not configured (noop client).
 */
export async function rateLimit({
  key,
  limit,
  windowSeconds
}: {
  key: string;
  limit: number;
  windowSeconds: number;
}): Promise<{ allowed: boolean; remaining: number; reset: number }> {
  // If redis is a noop (no UPSTASH_*), just allow
  if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
    return { allowed: true, remaining: limit, reset: Math.floor(Date.now() / 1000) + windowSeconds };
  }

  const now = Math.floor(Date.now() / 1000);
  const bucketKey = \`rl:\${key}\`;

  // Increment counter
  const currentRaw = await redis.get<number>(bucketKey);
  const current = typeof currentRaw === "number" ? currentRaw : 0;

  if (current >= limit) {
    const ttl = await redis.ttl(bucketKey as any).catch(() => -1 as any);
    const reset = ttl && ttl > 0 ? now + ttl : now + windowSeconds;
    return { allowed: false, remaining: 0, reset };
  }

  // First request sets TTL
  if (current === 0) {
    await redis.set(bucketKey, 1, { ex: windowSeconds });
  } else {
    await redis.set(bucketKey, current + 1);
  }

  return { allowed: true, remaining: Math.max(0, limit - (current + 1)), reset: now + windowSeconds };
}

/**
 * Resolve a best-effort client IP from request headers (Vercel-friendly).
 */
export function clientIpFromHeaders(headers: Headers): string {
  const forwardedFor = headers.get("x-forwarded-for");
  if (forwardedFor) {
    // take first IP in list
    const ip = forwardedFor.split(",")[0]?.trim();
    if (ip) return ip;
  }
  const realIp = headers.get("x-real-ip");
  if (realIp) return realIp;
  return "unknown";
}` },
      "apps/web/src/app/page.tsx": { lang: "tsx", content: `export default function HomePage() {
  return (
    <main>
      <h2 style={{ fontSize: 18, fontWeight: 600, marginBottom: 8 }}>Dashboard</h2>
      <p style={{ color: "#6b7280" }}>
        Bun venit în IzaManagement (Next.js). Navighează din bara de sus către Afecțiuni, Proceduri, Cursuri, AI sau Preview.
      </p>
      <div style={{ marginTop: 12 }}>
        <ul>
          <li><a href="/conditions" style={{ color: "#2563eb" }}>Afecțiuni</a></li>
          <li><a href="/procedures" style={{ color: "#2563eb" }}>Proceduri</a></li>
          <li><a href="/courses" style={{ color: "#2563eb" }}>Cursuri</a></li>
          <li><a href="/ai" style={{ color: "#2563eb" }}>AI</a></li>
          <li><a href="/admin" style={{ color: "#2563eb" }}>Admin</a></li>
        </ul>
      </div>
    </main>
  );
}` },
      "apps/web/src/app/ai/page.tsx": { lang: "tsx", content: `\"use client\";
import { useState } from "react";
type Msg = { role: "user" | "assistant"; content: string };

export default function AIPage() {
  const [messages, setMessages] = useState<Msg[]>([
    { role: "assistant", content: "Salut! Sunt asistentul AI IzaManagement. Cum te pot ajuta?" }
  ]);
  const [input, setInput] = useState("");
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function send() {
    if (!input.trim() || busy) return;
    setError(null);
    const next = [...messages, { role: "user", content: input.trim() } as Msg];
    setMessages(next);
    setInput("");
    setBusy(true);

    try {
      const res = await fetch("/api/ai-assistant/message", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messages: next })
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || \`HTTP \${res.status}\`);
      }
      const data = await res.json();
      setMessages((prev) => [...prev, { role: "assistant", content: String(data.content || "") }]);
    } catch (e) {
      setError((e as any)?.message || "Eroare necunoscută");
    } finally {
      setBusy(false);
    }
  }

  return (
    <main>
      <h2 style={{ fontSize: 18, fontWeight: 600, marginBottom: 8 }}>AI Assistant</h2>
      <p style={{ color: "#6b7280", marginBottom: 12 }}>
        Chat educațional pentru clinicieni (Groq). Configurează GROQ_API_KEY pentru răspunsuri reale.
      </p>

      <div style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12, minHeight: 320 }}>
        {messages.map((m, i) => (
          <div key={i} style={{ marginBottom: 10 }}>
            <div style={{ fontSize: 12, color: "#6b7280" }}>{m.role === "user" ? "Tu" : "Asistent"}</div>
            <div>{m.content}</div>
          </div>
        ))}
        {busy && <div style={{ color: "#6b7280" }}>Se generează răspunsul…</div>}
      </div>

      {error && <div style={{ color: "#b91c1c", marginTop: 8 }}>{error}</div>}

      <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => { if (e.key === "Enter") send(); }}
          placeholder="Scrie mesajul…"
          style={{ flex: 1, border: "1px solid #e5e7eb", borderRadius: 8, padding: "10px 12px" }}
        />
        <button
          onClick={send}
          disabled={busy}
          style={{
            backgroundColor: "#111827",
            color: "white",
            borderRadius: 8,
            padding: "10px 14px",
            fontWeight: 600,
            opacity: busy ? 0.7 : 1
          }}
        >
          Trimite
        </button>
      </div>
    </main>
  );
}` },
      "apps/web/src/app/admin/page.tsx": { lang: "tsx", content: `import { getServerSession } from "next-auth";
import { authOptions } from "@lib/auth";

export default async function AdminPage() {
  const session = await getServerSession(authOptions);
  const role = (session?.user as any)?.role ?? "guest";

  return (
    <main>
      <h2 style={{ fontSize: 18, fontWeight: 600, marginBottom: 8 }}>Panou admin</h2>
      {!session || role !== "admin" ? (
        <p>Te rugăm să te <a href="/login?callbackUrl=/admin" style={{ color: "#2563eb" }}>autentifici</a> ca administrator.</p>
      ) : (
        <ul>
          <li><a href="/admin/catalog" style={{ color: "#2563eb" }}>Administrare catalog</a></li>
        </ul>
      )}
    </main>
  );
}` },
      "apps/web/src/app/admin/catalog/page.tsx": { lang: "tsx", content: `/* truncated in preview; see repository file */` },
      "apps/web/src/app/api/health/route.ts": { lang: "typescript", content: `import { prisma } from "@lib/prisma";

export async function GET() {
  const hasGroq = !!process.env.GROQ_API_KEY;
  const hasRedis = !!process.env.UPSTASH_REDIS_REST_URL && !!process.env.UPSTASH_REDIS_REST_TOKEN;

  let dbOk = false;
  try {
    // lightweight, safe query that works even without tables (no-op)
    await prisma.$queryRaw\`SELECT 1\`;
    dbOk = true;
  } catch {
    dbOk = false;
  }

  const body = JSON.stringify({
    status: "healthy",
    db: dbOk ? "ok" : "not-configured",
    ai: hasGroq ? "configured" : "not-configured",
    redis: hasRedis ? "configured" : "not-configured",
    time: new Date().toISOString()
  });

  return new Response(body, {
    status: 200,
    headers: { "content-type": "application/json; charset=utf-8" }
  });
}` },
      "apps/web/src/app/api/seed/route.ts": { lang: "typescript", content: `import { prisma } from "@lib/prisma";
import bcrypt from "bcryptjs";

async function runSeed() {
  // Specialty
  const derm = await prisma.specialty.upsert({
    where: { slug: "dermatologie" },
    update: {},
    create: { slug: "dermatologie", name: "Dermatologie" }
  });

  // Conditions
  const conditions = [
    { slug: "acnee-vulgara", name: "Acnee vulgară", isCommon: true },
    { slug: "psoriazis", name: "Psoriazis", isCommon: true },
    { slug: "dermatita-atopica", name: "Dermatită atopică", isCommon: true },
    { slug: "dermatita-seboreica", name: "Dermatită seboreică", isCommon: true }
  ];

  for (const c of conditions) {
    await prisma.condition.upsert({
      where: { slug: c.slug },
      update: { name: c.name, isCommon: c.isCommon, specialtyId: derm.id },
      create: { ...c, specialtyId: derm.id }
    });
  }

  // Admin user
  const adminEmail = "admin@izamanagement.ro";
  const adminName = "Administrator";
  const plain = process.env.ADMIN_PASSWORD || "admin1234";
  const hash = await bcrypt.hash(plain, 10);

  await prisma.user.upsert({
    where: { email: adminEmail },
    update: { role: "admin", name: adminName, password: hash },
    create: { email: adminEmail, role: "admin", name: adminName, password: hash }
  });
}

export async function POST(req: Request) {
  const secret = process.env.SEED_SECRET;
  const provided = req.headers.get("x-seed-secret") ?? "";
  if (!secret || provided !== secret) {
    return new Response("Forbidden", { status: 403 });
  }

  try {
    await runSeed();
    return new Response("ok", { status: 200 });
  } catch (e: any) {
    return new Response(\`error: \${e?.message ?? "unknown"}\`, { status: 500 });
  }
}` },
      "apps/web/src/app/api/cron/every-15m/route.ts": { lang: "typescript", content: `export async function GET(req: Request) {
  const secret = process.env.CRON_SECRET;
  const provided = req.headers.get("x-cron-secret");
  if (secret && provided !== secret) {
    return new Response("Forbidden", { status: 403 });
  }
  // Optional: write to Upstash or log
  return new Response("ok");
}` },
      "apps/web/src/app/api/ai-assistant/message/route.ts": { lang: "typescript", content: `import { chat, type AIMessage } from "@lib/groq";
import { rateLimit, clientIpFromHeaders } from "@lib/rate-limit";

export async function POST(req: Request) {
  try {
    // Basic rate limit: 30 requests / 5 minutes per IP (if Upstash configured)
    const ip = clientIpFromHeaders(req.headers);
    const rl = await rateLimit({ key: \`ai:msg:\${ip}\`, limit: 30, windowSeconds: 300 });
    if (!rl.allowed) {
      return new Response("Rate limit exceeded. Try again later.", {
        status: 429,
        headers: { "Retry-After": String(Math.max(1, rl.reset - Math.floor(Date.now() / 1000))) }
      });
    }

    const body = await req.json().catch(() => ({}));
    const { messages, temperature, max_tokens, model } = body ?? {};

    if (!Array.isArray(messages) || messages.length === 0) {
      return new Response("messages[] is required", { status: 400 });
    }

    const sys: AIMessage = {
      role: "system",
      content:
        "You are a helpful, careful medical assistant for Romanian clinicians. " +
        "You provide educational guidance, not medical advice for patients. " +
        "Always remind to consult clinical guidelines and use clinical judgment."
    };

    const normalized: AIMessage[] = [sys, ...messages.map((m: any) => ({
      role: m.role === "assistant" ? "assistant" : m.role === "system" ? "system" : "user",
      content: String(m.content ?? "")
    }))];

    const result = await chat({
      messages: normalized,
      temperature: typeof temperature === "number" ? temperature : 0.2,
      max_tokens: typeof max_tokens === "number" ? max_tokens : 800,
      model: typeof model === "string" && model ? model : undefined
    });

    return Response.json({ content: result.content, model: model || process.env.GROQ_MODEL || "llama-3.1-70b-versatile" });
  } catch (e: any) {
    const msg = e?.message || "unknown";
    if (msg.includes("GROQ_API_KEY")) {
      return new Response("AI not configured (set GROQ_API_KEY)", { status: 501 });
    }
    return new Response(\`error: \${msg}\`, { status: 500 });
  }
}` },
      "apps/web/src/app/api/ai-assistant/differential-diagnosis/route.ts": { lang: "typescript", content: `import { chat, type AIMessage } from "@lib/groq";
import { rateLimit, clientIpFromHeaders } from "@lib/rate-limit";

export async function POST(req: Request) {
  try {
    // 20 DDx requests / 5 minutes per IP
    const ip = clientIpFromHeaders(req.headers);
    const rl = await rateLimit({ key: \`ai:ddx:\${ip}\`, limit: 20, windowSeconds: 300 });
    if (!rl.allowed) {
      return new Response("Rate limit exceeded. Try again later.", {
        status: 429,
        headers: { "Retry-After": String(Math.max(1, rl.reset - Math.floor(Date.now() / 1000))) }
      });
    }

    const body = await req.json().catch(() => ({}));
    const { symptoms = [], age, gender, context } = body ?? {};

    if (!Array.isArray(symptoms) || symptoms.length === 0) {
      return new Response("symptoms[] is required", { status: 400 });
    }

    const prompt = [
      "Ești un asistent pentru diagnostic diferențial. Primești simptome, vârstă, sex și opțional context.",
      "Returnează:",
      "1) 5-8 diagnostice diferențiale probabile (cu probabilitate aproximativă)",
      "2) Red flags / criterii de gravitate",
      "3) Întrebări suplimentare utile",
      "4) Investigații inițiale recomandate (de clasă generală, nu branduri)",
      "5) Trimiteri / când este indicată",
      "",
      "Important: Acesta este conținut educațional, nu recomandare medicală pentru pacienți."
    ].join("\\n");

    const messages: AIMessage[] = [
      { role: "system", content: prompt },
      {
        role: "user",
        content: JSON.stringify({ symptoms, age, gender, context }, null, 2)
      }
    ];

    const result = await chat({ messages, max_tokens: 900 });
    return Response.json({ content: result.content });
  } catch (e: any) {
    const msg = e?.message || "unknown";
    if (msg.includes("GROQ_API_KEY")) {
      return new Response("AI not configured (set GROQ_API_KEY)", { status: 501 });
    }
    return new Response(\`error: \${msg}\`, { status: 500 });
  }
}` },
      "apps/web/src/app/api/ai-assistant/analyze-images/route.ts": { lang: "typescript", content: `const REPLICATE_API = "https://api.replicate.com/v1/predictions";

/**
 * Minimal image analysis using Replicate if REPLICATE_API_TOKEN is set.
 * Expects JSON body: { imageUrls: string[], context?: string }
 * Uses "methexis-inc/img2prompt" to generate a textual description per image (free/cheap tier friendly).
 */
export async function POST(req: Request) {
  try {
    const token = process.env.REPLICATE_API_TOKEN;
    if (!token) {
      return new Response("Image analysis not configured (set REPLICATE_API_TOKEN)", { status: 501 });
    }

    const body = await req.json().catch(() => ({}));
    const { imageUrls = [], context = "" } = body ?? {};
    if (!Array.isArray(imageUrls) || imageUrls.length === 0) {
      return new Response("imageUrls[] is required", { status: 400 });
    }

    const outputs: Array<{ url: string; description: string | null }> = [];

    for (const url of imageUrls) {
      const resp = await fetch(REPLICATE_API, {
        method: "POST",
        headers: {
          Authorization: \`Token \${token}\`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          version: "21ed7b6e76b2bdc3c7ebd6b246c9181d8e4da2982cd870be51bfc2d53da95e97", // methexis-inc/img2prompt
          input: { image: url }
        })
      });

      if (!resp.ok) {
        const txt = await resp.text();
        outputs.push({ url, description: \`error: \${resp.status} \${txt}\` });
        continue;
      }

      const json = await resp.json();
      const id = json?.id;

      // poll until completed or failed
      let status = json?.status;
      let result: any = json;
      for (let i = 0; i < 30 && status && status !== "succeeded" && status !== "failed" && status !== "canceled"; i++) {
        await new Promise(r => setTimeout(r, 2000));
        const check = await fetch(\`\${REPLICATE_API}/\${id}\`, {
          headers: { Authorization: \`Token \${token}\` }
        });
        result = await check.json();
        status = result?.status;
      }

      if (status !== "succeeded") {
        outputs.push({ url, description: \`status: \${status || "unknown"}\` });
      } else {
        const description = Array.isArray(result?.output) ? String(result.output[0] ?? "") : String(result?.output ?? "");
        outputs.push({ url, description });
      }
    }

    return Response.json({ context, outputs });
  } catch (e: any) {
    return new Response(\`error: \${e?.message || "unknown"}\`, { status: 500 });
  }
}` },
      ".github/workflows/cron.yml": { lang: "yaml", content: `name: Cron - Every 15 Minutes
on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

jobs:
  ping:
    runs-on: ubuntu-latest
    steps:
      - name: Ping cron endpoint
        run: |
          curl -s -S -X GET "$CRON_URL" -H "x-cron-secret: $CRON_SECRET" || true
        env:
          CRON_URL: \${{ secrets.CRON_URL }}
          CRON_SECRET: \${{ secrets.CRON_SECRET }}` }
    };

    const sidebar = document.getElementById('sidebar');
    const codeEl = document.getElementById('code');
    const filenameEl = document.getElementById('filename');
    const langEl = document.getElementById('lang');

    function renderFile(name) {
      const item = files[name];
      filenameEl.textContent = name;
      langEl.textContent = item.lang;

      codeEl.className = '';
      codeEl.classList.add('language-' + item.lang);
      codeEl.textContent = item.content;

      document.querySelectorAll('.file').forEach(el => el.classList.remove('active'));
      const active = document.querySelector('.file[data-file="'+name+'"]');
      if (active) active.classList.add('active');

      hljs.highlightElement(codeEl);
    }

    document.querySelectorAll('.file').forEach(el => {
      el.addEventListener('click', () => renderFile(el.getAttribute('data-file')));
    });

    renderFile('apps/web/next.config.mjs');
  </script>
</body>
</html>